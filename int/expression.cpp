#include "idm/id.h"
#include "common/include/util.h"
using namespace llvm;

#include "expression.h"
#include "capture.h"
using namespace slicer;

bool CompareClause::operator()(const Clause *a, const Clause *b) {
	string str_a, str_b;
	raw_string_ostream oss_a(str_a), oss_b(str_b);
	print_clause(oss_a, a, OI);
	print_clause(oss_b, b, OI);
	return oss_a.str() < oss_b.str();
}

Expr *Expr::clone() const {
	if (type == SingleDef)
		return new Expr(v);
	if (type == SingleUse)
		return new Expr(u);
	if (type == Unary)
		return new Expr(op, e1->clone());
	if (type == Binary)
		return new Expr(op, e1->clone(), e2->clone());
	assert_unreachable();
}

unsigned Expr::get_width() const {
	if (type == SingleDef || type == SingleUse) {
		const Value *val = (type == SingleDef ? v : u->get());
		return (val->getType()->isIntegerTy(1) ? 1 : 32);
	}
	if (type == Unary) {
		if (op == Instruction::Trunc)
			return 1;
		else
			return 32;
	}
	if (type == Binary) {
		assert(e1->get_width() == e2->get_width());
		return e1->get_width();
	}
	assert_unreachable();
}

Expr::Expr(unsigned opcode, Expr *expr1, Expr *expr2):
	type(Binary), op(opcode), e1(expr1), e2(expr2), v(NULL)
{
	assert(e1->get_width() == e2->get_width());
	switch (opcode) {
		case Instruction::Add:
		case Instruction::Sub:
		case Instruction::Mul:
		case Instruction::UDiv:
		case Instruction::SDiv:
		case Instruction::URem:
		case Instruction::SRem:
		case Instruction::Shl:
		case Instruction::LShr:
		case Instruction::AShr:
		case Instruction::And:
		case Instruction::Or:
		case Instruction::Xor:
			break;
		default: assert_not_supported();
	}
}

void slicer::print_opcode(raw_ostream &O, unsigned op) {
	switch (op) {
		case Instruction::Add:
			O << "+";
			break;
		case Instruction::Sub:
			O << "-";
			break;
		case Instruction::Mul:
			O << "*";
			break;
		case Instruction::UDiv:
		case Instruction::SDiv:
			O << "/";
			break;
		case Instruction::URem:
		case Instruction::SRem:
			O << "%";
			break;
		case Instruction::Shl:
			O << "<<";
			break;
		case Instruction::LShr:
		case Instruction::AShr:
			O << ">>";
			break; // FIXME: distinguish them
		case Instruction::And:
			O << "&";
			break;
		case Instruction::Or:
			O << "|";
			break;
		case Instruction::Xor:
			O << "^";
			break;
		case Instruction::ZExt:
		case Instruction::SExt:
			O << "<";
			break;
		case Instruction::Trunc:
			O << ">";
		default: assert_not_supported();
	}
}

void slicer::print_predicate(raw_ostream &O, CmpInst::Predicate p) {
	switch (p) {
		case CmpInst::ICMP_EQ:
			O << "=";
			break;
		case CmpInst::ICMP_NE:
			O << "!=";
			break;
		case CmpInst::ICMP_UGT:
		case CmpInst::ICMP_SGT:
			O << ">";
			break;
		case CmpInst::ICMP_UGE:
		case CmpInst::ICMP_SGE:
			O << ">=";
			break;
		case CmpInst::ICMP_ULT:
		case CmpInst::ICMP_SLT:
			O << "<";
			break;
		case CmpInst::ICMP_ULE:
		case CmpInst::ICMP_SLE:
			O << "<=";
			break;
		default: assert(false && "Invalid predicate");
	}
}

void slicer::print_expr(raw_ostream &O, const Expr *e, ObjectID &OI) {
	if (e->type == Expr::SingleDef || e->type == Expr::SingleUse) {
		const Value *v = (e->type == Expr::SingleDef ? e->v : e->u->get());
		// Some ConstantInts are generated by our constraint capturer. 
		// They don't appear in the original module. 
		if (const ConstantInt *ci = dyn_cast<ConstantInt>(v)) {
			if (ci->getType()->getBitWidth() == 1)
				O << ci->getZExtValue();
			else
				O << ci->getSExtValue();
		} else {
			unsigned value_id = OI.getValueID(v);
			assert(value_id != ObjectID::INVALID_ID);
			O << "x" << value_id;
		}
	} else if (e->type == Expr::Unary) {
		O << "(";
		print_opcode(O, e->op);
		O << " ";
		print_expr(O, e->e1, OI);
		O << ")";
	} else if (e->type == Expr::Binary) {
		O << "(";
		print_expr(O, e->e1, OI);
		O << " ";
		print_opcode(O, e->op);
		O << " ";
		print_expr(O, e->e2, OI);
		O << ")";
	} else
		assert(false && "Unknown type");
}

void slicer::print_bool_expr(raw_ostream &O, const BoolExpr *be, ObjectID &OI) {
	O << "(";
	print_expr(O, be->e1, OI);
	O << " ";
	print_predicate(O, be->p);
	O << " ";
	print_expr(O, be->e2, OI);
	O << ")";
}

void slicer::print_clause(raw_ostream &O, const Clause *c, ObjectID &OI) {
	if (c->be) {
		print_bool_expr(O, c->be, OI);
		return;
	}
	O << "(";
	print_clause(O, c->c1, OI);
	if (c->op == Instruction::And)
		O << " AND ";
	else if (c->op == Instruction::Or)
		O << " OR ";
	else
		O << " XOR ";
	print_clause(O, c->c2, OI);
	O << ")";
}
