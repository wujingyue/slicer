#include "idm/id.h"
using namespace llvm;

#include "expression.h"
#include "capture.h"

namespace slicer {

	void print_opcode(raw_ostream &O, unsigned op) {
		switch (op) {
			case Instruction::Add:
				O << "+";
				break;
			case Instruction::Sub:
				O << "-";
				break;
			case Instruction::Mul:
				O << "*";
				break;
			case Instruction::UDiv:
			case Instruction::SDiv:
				O << "/";
				break;
			case Instruction::URem:
			case Instruction::SRem:
				O << "%";
				break;
			case Instruction::Shl:
				O << "<<";
				break;
			case Instruction::LShr:
			case Instruction::AShr:
				O << ">>";
				break; // FIXME: distinguish them
			case Instruction::And:
				O << "&";
				break;
			case Instruction::Or:
				O << "|";
				break;
			case Instruction::Xor:
				O << "^";
				break;
			default: assert_not_supported();
		}
	}

	void print_predicate(raw_ostream &O, CmpInst::Predicate p) {
		switch (p) {
			case CmpInst::ICMP_EQ:
				O << "=";
				break;
			case CmpInst::ICMP_NE:
				O << "!=";
				break;
			case CmpInst::ICMP_UGT:
			case CmpInst::ICMP_SGT:
				O << ">";
				break;
			case CmpInst::ICMP_UGE:
			case CmpInst::ICMP_SGE:
				O << ">=";
				break;
			case CmpInst::ICMP_ULT:
			case CmpInst::ICMP_SLT:
				O << "<";
				break;
			case CmpInst::ICMP_ULE:
			case CmpInst::ICMP_SLE:
				O << "<=";
				break;
			default: assert(false && "Invalid predicate");
		}
	}

	void print_expr(raw_ostream &O, const Expr *e, ObjectID &OI) {
		if (e->type == Expr::SingleDef || e->type == Expr::SingleUse) {
			const Value *v = (e->type == Expr::SingleDef ? e->v : e->u->get());
			// Some ConstantInts are generated by our constraint capturer. 
			// They don't appear in the original module. 
			if (const ConstantInt *ci = dyn_cast<ConstantInt>(v)) {
				O << ci->getSExtValue();
			} else {
				unsigned value_id = OI.getValueID(v);
				assert(value_id != ObjectID::INVALID_ID);
				O << "x" << value_id;
			}
		} else if (e->type == Expr::Unary) {
			O << "(";
			print_opcode(O, e->op);
			O << " ";
			print_expr(O, e->e1, OI);
			O << ")";
		} else if (e->type == Expr::Binary) {
			O << "(";
			print_expr(O, e->e1, OI);
			O << " ";
			print_opcode(O, e->op);
			O << " ";
			print_expr(O, e->e2, OI);
			O << ")";
		} else
			assert(false && "Unknown type");
	}

	void print_bool_expr(raw_ostream &O, const BoolExpr *be, ObjectID &OI) {
		O << "(";
		print_expr(O, be->e1, OI);
		O << " ";
		print_predicate(O, be->p);
		O << " ";
		print_expr(O, be->e2, OI);
		O << ")";
	}

	void print_clause(raw_ostream &O, const Clause *c, ObjectID &OI) {
		if (c->be) {
			print_bool_expr(O, c->be, OI);
			return;
		}
		O << "(";
		print_clause(O, c->c1, OI);
		if (c->op == Instruction::And)
			O << " AND ";
		else if (c->op == Instruction::Or)
			O << " OR ";
		else
			O << " XOR ";
		print_clause(O, c->c2, OI);
		O << ")";
	}
}
